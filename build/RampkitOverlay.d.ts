import { RampKitContext } from "./types";
export declare const injectedHardening = "\n(function(){\n  try {\n    var meta = document.querySelector('meta[name=\"viewport\"]');\n    if (!meta) { meta = document.createElement('meta'); meta.name = 'viewport'; document.head.appendChild(meta); }\n    meta.setAttribute('content','width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover');\n    var style = document.createElement('style');\n    style.textContent='html,body{overflow-x:hidden!important;} html,body,*{-webkit-user-select:none!important;user-select:none!important;-webkit-touch-callout:none!important;-ms-user-select:none!important;touch-action: pan-y;} *{-webkit-tap-highlight-color: rgba(0,0,0,0)!important;} ::selection{background: transparent!important;} ::-moz-selection{background: transparent!important;} a,img{-webkit-user-drag:none!important;user-drag:none!important;-webkit-touch-callout:none!important} input,textarea{caret-color:transparent!important;-webkit-user-select:none!important;user-select:none!important}';\n    document.head.appendChild(style);\n    var prevent=function(e){e.preventDefault&&e.preventDefault();};\n    document.addEventListener('gesturestart',prevent,{passive:false});\n    document.addEventListener('gesturechange',prevent,{passive:false});\n    document.addEventListener('gestureend',prevent,{passive:false});\n    document.addEventListener('dblclick',prevent,{passive:false});\n    document.addEventListener('wheel',function(e){ if(e.ctrlKey) e.preventDefault(); },{passive:false});\n    document.addEventListener('touchmove',function(e){ if(e.scale && e.scale !== 1) e.preventDefault(); },{passive:false});\n    document.addEventListener('selectstart',prevent,{passive:false,capture:true});\n    document.addEventListener('contextmenu',prevent,{passive:false,capture:true});\n    document.addEventListener('copy',prevent,{passive:false,capture:true});\n    document.addEventListener('cut',prevent,{passive:false,capture:true});\n    document.addEventListener('paste',prevent,{passive:false,capture:true});\n    document.addEventListener('dragstart',prevent,{passive:false,capture:true});\n    // Belt-and-suspenders: aggressively clear any attempted selection\n    var clearSel=function(){\n      try{var sel=window.getSelection&&window.getSelection(); if(sel&&sel.removeAllRanges) sel.removeAllRanges();}catch(_){} }\n    document.addEventListener('selectionchange',clearSel,{passive:true,capture:true});\n    document.onselectstart=function(){ clearSel(); return false; };\n    try{ document.documentElement.style.webkitUserSelect='none'; document.documentElement.style.userSelect='none'; }catch(_){ }\n    try{ document.body.style.webkitUserSelect='none'; document.body.style.userSelect='none'; }catch(_){ }\n    var __selTimer = setInterval(clearSel, 160);\n    window.addEventListener('pagehide',function(){ try{ clearInterval(__selTimer); }catch(_){} });\n    // Continuously enforce no-select on all elements and new nodes\n    var enforceNoSelect = function(el){\n      try{\n        el.style && (el.style.webkitUserSelect='none', el.style.userSelect='none', el.style.webkitTouchCallout='none');\n        el.setAttribute && (el.setAttribute('unselectable','on'), el.setAttribute('contenteditable','false'));\n      }catch(_){}\n    }\n    try{\n      var all=document.getElementsByTagName('*');\n      for(var i=0;i<all.length;i++){ enforceNoSelect(all[i]); }\n      var obs = new MutationObserver(function(muts){\n        for(var j=0;j<muts.length;j++){\n          var m=muts[j];\n          if(m.type==='childList'){\n            m.addedNodes && m.addedNodes.forEach && m.addedNodes.forEach(function(n){ if(n && n.nodeType===1){ enforceNoSelect(n); var q=n.getElementsByTagName? n.getElementsByTagName('*'): []; for(var k=0;k<q.length;k++){ enforceNoSelect(q[k]); }}});\n          } else if(m.type==='attributes'){\n            enforceNoSelect(m.target);\n          }\n        }\n      });\n      obs.observe(document.documentElement,{ childList:true, subtree:true, attributes:true, attributeFilter:['contenteditable','style'] });\n    }catch(_){ }\n  } catch(_) {}\n})(); true;\n";
export declare const injectedNoSelect = "\n(function(){\n  try {\n    if (window.__rkNoSelectApplied) return true;\n    window.__rkNoSelectApplied = true;\n    var style = document.getElementById('rk-no-select-style');\n    if (!style) {\n      style = document.createElement('style');\n      style.id = 'rk-no-select-style';\n      style.innerHTML = \"\n        * {\n          user-select: none !important;\n          -webkit-user-select: none !important;\n          -webkit-touch-callout: none !important;\n        }\n        ::selection {\n          background: transparent !important;\n        }\n      \";\n      document.head.appendChild(style);\n    }\n    var prevent = function(e){ if(e && e.preventDefault) e.preventDefault(); return false; };\n    document.addEventListener('contextmenu', prevent, { passive: false, capture: true });\n    document.addEventListener('selectstart', prevent, { passive: false, capture: true });\n  } catch (_) {}\n  true;\n})();\n";
export declare const injectedVarsHandler = "\n(function(){\n  try {\n    if (window.__rkVarsHandlerApplied) return true;\n    window.__rkVarsHandlerApplied = true;\n    \n    // Handler function that updates variables and notifies the page\n    window.__rkHandleVarsUpdate = function(vars) {\n      if (!vars || typeof vars !== 'object') return;\n      // Update the global variables object\n      window.__rampkitVariables = vars;\n      // Dispatch a custom event that the page's JS can listen to for re-rendering\n      try {\n        document.dispatchEvent(new CustomEvent('rampkit:vars-updated', { detail: vars }));\n      } catch(e) {}\n      // Also try calling a global handler if the page defined one\n      try {\n        if (typeof window.onRampkitVarsUpdate === 'function') {\n          window.onRampkitVarsUpdate(vars);\n        }\n      } catch(e) {}\n    };\n    \n    // Listen for message events from React Native\n    document.addEventListener('message', function(event) {\n      try {\n        var data = event.data;\n        if (data && data.type === 'rampkit:variables' && data.vars) {\n          window.__rkHandleVarsUpdate(data.vars);\n        }\n      } catch(e) {}\n    }, false);\n    \n    // Also listen on window for compatibility\n    window.addEventListener('message', function(event) {\n      try {\n        var data = event.data;\n        if (data && data.type === 'rampkit:variables' && data.vars) {\n          window.__rkHandleVarsUpdate(data.vars);\n        }\n      } catch(e) {}\n    }, false);\n  } catch (_) {}\n  true;\n})();\n";
export declare const injectedButtonAnimations = "\n(function(){\n  try {\n    if (window.__rkButtonAnimApplied) return true;\n    window.__rkButtonAnimApplied = true;\n    \n    // Add styles for button animations\n    var style = document.createElement('style');\n    style.id = 'rk-button-anim-style';\n    style.innerHTML = `\n      /* Base transition for all interactive elements */\n      [data-rampkit-action],\n      [data-rampkit-navigate],\n      [data-rampkit-tap],\n      [onclick],\n      button,\n      a[href],\n      .rk-interactive,\n      .rk-button {\n        transform: scale(1);\n        opacity: 1;\n        will-change: transform, opacity;\n      }\n      \n      /* Pressed state - applied via JS */\n      .rk-pressed {\n        transform: scale(0.97) !important;\n        opacity: 0.8 !important;\n        transition: transform 80ms cubic-bezier(0.25, 0.1, 0.25, 1), \n                    opacity 80ms cubic-bezier(0.25, 0.1, 0.25, 1) !important;\n      }\n      \n      /* Released state - spring-like bounce back */\n      .rk-released {\n        transform: scale(1) !important;\n        opacity: 1 !important;\n        transition: transform 280ms cubic-bezier(0.34, 1.56, 0.64, 1), \n                    opacity 280ms cubic-bezier(0.34, 1.56, 0.64, 1) !important;\n      }\n    `;\n    document.head.appendChild(style);\n    \n    // Check if element is interactive\n    function isInteractive(el) {\n      if (!el || !el.tagName) return false;\n      var tag = el.tagName.toLowerCase();\n      if (tag === 'button' || tag === 'a') return true;\n      if (el.hasAttribute('data-rampkit-action')) return true;\n      if (el.hasAttribute('data-rampkit-navigate')) return true;\n      if (el.hasAttribute('data-rampkit-tap')) return true;\n      if (el.hasAttribute('onclick')) return true;\n      if (el.classList.contains('rk-interactive')) return true;\n      if (el.classList.contains('rk-button')) return true;\n      return false;\n    }\n    \n    // Find the interactive parent element\n    function findInteractiveElement(el) {\n      var current = el;\n      var maxDepth = 10; // Prevent infinite loops\n      while (current && maxDepth > 0) {\n        if (isInteractive(current)) return current;\n        current = current.parentElement;\n        maxDepth--;\n      }\n      return null;\n    }\n    \n    // Track currently pressed element\n    var pressedElement = null;\n    var pressTimeout = null;\n    \n    // Handle touch start - immediate press animation\n    function handleTouchStart(e) {\n      try {\n        var target = findInteractiveElement(e.target);\n        if (!target) return;\n        \n        // Clear any pending release animation\n        if (pressTimeout) {\n          clearTimeout(pressTimeout);\n          pressTimeout = null;\n        }\n        \n        // Remove released class and add pressed class\n        target.classList.remove('rk-released');\n        target.classList.add('rk-pressed');\n        pressedElement = target;\n      } catch(_) {}\n    }\n    \n    // Handle touch end - spring release animation\n    function handleTouchEnd(e) {\n      try {\n        if (!pressedElement) return;\n        var target = pressedElement;\n        \n        // Switch from pressed to released for spring animation\n        target.classList.remove('rk-pressed');\n        target.classList.add('rk-released');\n        \n        // Clean up after animation completes\n        pressTimeout = setTimeout(function() {\n          target.classList.remove('rk-released');\n          pressTimeout = null;\n        }, 300);\n        \n        pressedElement = null;\n      } catch(_) {}\n    }\n    \n    // Handle touch cancel - reset without animation\n    function handleTouchCancel(e) {\n      try {\n        if (!pressedElement) return;\n        pressedElement.classList.remove('rk-pressed');\n        pressedElement.classList.remove('rk-released');\n        pressedElement = null;\n        if (pressTimeout) {\n          clearTimeout(pressTimeout);\n          pressTimeout = null;\n        }\n      } catch(_) {}\n    }\n    \n    // Use capture phase to get events before they're handled\n    document.addEventListener('touchstart', handleTouchStart, { passive: true, capture: true });\n    document.addEventListener('touchend', handleTouchEnd, { passive: true, capture: true });\n    document.addEventListener('touchcancel', handleTouchCancel, { passive: true, capture: true });\n    \n    // Also handle mouse events for web testing\n    document.addEventListener('mousedown', handleTouchStart, { passive: true, capture: true });\n    document.addEventListener('mouseup', handleTouchEnd, { passive: true, capture: true });\n    document.addEventListener('mouseleave', handleTouchCancel, { passive: true, capture: true });\n    \n  } catch (_) {}\n  true;\n})();\n";
export type ScreenPayload = {
    id: string;
    html: string;
    css?: string;
    js?: string;
};
export declare function showRampkitOverlay(opts: {
    onboardingId: string;
    screens: ScreenPayload[];
    variables?: Record<string, any>;
    requiredScripts?: string[];
    rampkitContext?: RampKitContext;
    onClose?: () => void;
    onOnboardingFinished?: (payload?: any) => void;
    onShowPaywall?: (payload?: any) => void;
    onScreenChange?: (screenIndex: number, screenId: string) => void;
    onOnboardingAbandoned?: (reason: string, lastScreenIndex: number, lastScreenId: string) => void;
    onNotificationPermissionRequested?: () => void;
    onNotificationPermissionResult?: (granted: boolean) => void;
}): void;
export declare function hideRampkitOverlay(): void;
export declare function closeRampkitOverlay(): void;
export declare function preloadRampkitOverlay(opts: {
    onboardingId: string;
    screens: ScreenPayload[];
    variables?: Record<string, any>;
    requiredScripts?: string[];
    rampkitContext?: RampKitContext;
}): void;
declare function Overlay(props: {
    onboardingId: string;
    screens: ScreenPayload[];
    variables?: Record<string, any>;
    requiredScripts?: string[];
    rampkitContext?: RampKitContext;
    prebuiltDocs?: string[];
    onRequestClose: () => void;
    onOnboardingFinished?: (payload?: any) => void;
    onShowPaywall?: (payload?: any) => void;
    onRegisterClose?: (handler: (() => void) | null) => void;
    onScreenChange?: (screenIndex: number, screenId: string) => void;
    onOnboardingAbandoned?: (reason: string, lastScreenIndex: number, lastScreenId: string) => void;
    onNotificationPermissionRequested?: () => void;
    onNotificationPermissionResult?: (granted: boolean) => void;
}): any;
export default Overlay;
