import { RampKitContext, NavigationData } from "./types";
export declare const injectedHardening = "\n(function(){\n  try {\n    var meta = document.querySelector('meta[name=\"viewport\"]');\n    if (!meta) { meta = document.createElement('meta'); meta.name = 'viewport'; document.head.appendChild(meta); }\n    meta.setAttribute('content','width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover');\n    var style = document.createElement('style');\n    style.textContent='html,body{overflow-x:hidden!important;} html,body,*{-webkit-user-select:none!important;user-select:none!important;-webkit-touch-callout:none!important;-ms-user-select:none!important;touch-action: pan-y;} *{-webkit-tap-highlight-color: rgba(0,0,0,0)!important;} ::selection{background: transparent!important;} ::-moz-selection{background: transparent!important;} a,img{-webkit-user-drag:none!important;user-drag:none!important;-webkit-touch-callout:none!important} input,textarea{caret-color:transparent!important;-webkit-user-select:none!important;user-select:none!important}';\n    document.head.appendChild(style);\n    var prevent=function(e){e.preventDefault&&e.preventDefault();};\n    document.addEventListener('gesturestart',prevent,{passive:false});\n    document.addEventListener('gesturechange',prevent,{passive:false});\n    document.addEventListener('gestureend',prevent,{passive:false});\n    document.addEventListener('dblclick',prevent,{passive:false});\n    document.addEventListener('wheel',function(e){ if(e.ctrlKey) e.preventDefault(); },{passive:false});\n    document.addEventListener('touchmove',function(e){ if(e.scale && e.scale !== 1) e.preventDefault(); },{passive:false});\n    document.addEventListener('selectstart',prevent,{passive:false,capture:true});\n    document.addEventListener('contextmenu',prevent,{passive:false,capture:true});\n    document.addEventListener('copy',prevent,{passive:false,capture:true});\n    document.addEventListener('cut',prevent,{passive:false,capture:true});\n    document.addEventListener('paste',prevent,{passive:false,capture:true});\n    document.addEventListener('dragstart',prevent,{passive:false,capture:true});\n    // Belt-and-suspenders: aggressively clear any attempted selection\n    var clearSel=function(){\n      try{var sel=window.getSelection&&window.getSelection(); if(sel&&sel.removeAllRanges) sel.removeAllRanges();}catch(_){} }\n    document.addEventListener('selectionchange',clearSel,{passive:true,capture:true});\n    document.onselectstart=function(){ clearSel(); return false; };\n    try{ document.documentElement.style.webkitUserSelect='none'; document.documentElement.style.userSelect='none'; }catch(_){ }\n    try{ document.body.style.webkitUserSelect='none'; document.body.style.userSelect='none'; }catch(_){ }\n    var __selTimer = setInterval(clearSel, 160);\n    window.addEventListener('pagehide',function(){ try{ clearInterval(__selTimer); }catch(_){} });\n    // Continuously enforce no-select on all elements and new nodes\n    var enforceNoSelect = function(el){\n      try{\n        el.style && (el.style.webkitUserSelect='none', el.style.userSelect='none', el.style.webkitTouchCallout='none');\n        el.setAttribute && (el.setAttribute('unselectable','on'), el.setAttribute('contenteditable','false'));\n      }catch(_){}\n    }\n    try{\n      var all=document.getElementsByTagName('*');\n      for(var i=0;i<all.length;i++){ enforceNoSelect(all[i]); }\n      var obs = new MutationObserver(function(muts){\n        for(var j=0;j<muts.length;j++){\n          var m=muts[j];\n          if(m.type==='childList'){\n            m.addedNodes && m.addedNodes.forEach && m.addedNodes.forEach(function(n){ if(n && n.nodeType===1){ enforceNoSelect(n); var q=n.getElementsByTagName? n.getElementsByTagName('*'): []; for(var k=0;k<q.length;k++){ enforceNoSelect(q[k]); }}});\n          } else if(m.type==='attributes'){\n            enforceNoSelect(m.target);\n          }\n        }\n      });\n      obs.observe(document.documentElement,{ childList:true, subtree:true, attributes:true, attributeFilter:['contenteditable','style'] });\n    }catch(_){ }\n  } catch(_) {}\n})(); true;\n";
export declare const injectedNoSelect = "\n(function(){\n  try {\n    if (window.__rkNoSelectApplied) return true;\n    window.__rkNoSelectApplied = true;\n    var style = document.getElementById('rk-no-select-style');\n    if (!style) {\n      style = document.createElement('style');\n      style.id = 'rk-no-select-style';\n      style.innerHTML = \"\n        * {\n          user-select: none !important;\n          -webkit-user-select: none !important;\n          -webkit-touch-callout: none !important;\n        }\n        ::selection {\n          background: transparent !important;\n        }\n      \";\n      document.head.appendChild(style);\n    }\n    var prevent = function(e){ if(e && e.preventDefault) e.preventDefault(); return false; };\n    document.addEventListener('contextmenu', prevent, { passive: false, capture: true });\n    document.addEventListener('selectstart', prevent, { passive: false, capture: true });\n  } catch (_) {}\n  true;\n})();\n";
export declare const injectedVarsHandler = "\n(function(){\n  try {\n    if (window.__rkVarsHandlerApplied) return true;\n    window.__rkVarsHandlerApplied = true;\n    \n    // Handler function that updates variables and notifies the page\n    window.__rkHandleVarsUpdate = function(vars) {\n      if (!vars || typeof vars !== 'object') return;\n      // Update the global variables object\n      window.__rampkitVariables = vars;\n      // Dispatch a custom event that the page's JS can listen to for re-rendering\n      try {\n        document.dispatchEvent(new CustomEvent('rampkit:vars-updated', { detail: vars }));\n      } catch(e) {}\n      // Also try calling a global handler if the page defined one\n      try {\n        if (typeof window.onRampkitVarsUpdate === 'function') {\n          window.onRampkitVarsUpdate(vars);\n        }\n      } catch(e) {}\n    };\n    \n    // Listen for message events from React Native\n    document.addEventListener('message', function(event) {\n      try {\n        var data = event.data;\n        if (data && data.type === 'rampkit:variables' && data.vars) {\n          window.__rkHandleVarsUpdate(data.vars);\n        }\n      } catch(e) {}\n    }, false);\n    \n    // Also listen on window for compatibility\n    window.addEventListener('message', function(event) {\n      try {\n        var data = event.data;\n        if (data && data.type === 'rampkit:variables' && data.vars) {\n          window.__rkHandleVarsUpdate(data.vars);\n        }\n      } catch(e) {}\n    }, false);\n  } catch (_) {}\n  true;\n})();\n";
export declare const injectedDynamicTapHandler = "\n(function() {\n    if (window.__rampkitClickInterceptorInstalled) return;\n    window.__rampkitClickInterceptorInstalled = true;\n\n    // Decode HTML entities\n    function decodeHtml(str) {\n        if (!str) return str;\n        return str.replace(/&quot;/g, '\"').replace(/&#34;/g, '\"').replace(/&#x22;/g, '\"')\n                  .replace(/&apos;/g, \"'\").replace(/&#39;/g, \"'\").replace(/&#x27;/g, \"'\")\n                  .replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');\n    }\n\n    // Find dynamic tap config on element or ancestors\n    function findDynamicTap(el) {\n        var current = el;\n        var depth = 0;\n        var attrNames = ['data-tap-dynamic', 'data-tapdynamic', 'tapDynamic', 'data-dynamic-tap'];\n        while (current && current !== document.body && current !== document.documentElement && depth < 20) {\n            if (current.getAttribute) {\n                for (var i = 0; i < attrNames.length; i++) {\n                    var attr = current.getAttribute(attrNames[i]);\n                    if (attr && attr.length > 2) {\n                        return { element: current, config: attr };\n                    }\n                }\n                if (current.dataset && current.dataset.tapDynamic) {\n                    return { element: current, config: current.dataset.tapDynamic };\n                }\n            }\n            current = current.parentElement;\n            depth++;\n        }\n        return null;\n    }\n    \n    // Get variables for condition evaluation - check ALL possible sources\n    function getVars() {\n        var vars = {};\n        if (window.__rampkitVariables) {\n            Object.keys(window.__rampkitVariables).forEach(function(k) {\n                vars[k] = window.__rampkitVariables[k];\n            });\n        }\n        if (window.__rampkitVars) {\n            Object.keys(window.__rampkitVars).forEach(function(k) {\n                vars[k] = window.__rampkitVars[k];\n            });\n        }\n        if (window.RK_VARS) {\n            Object.keys(window.RK_VARS).forEach(function(k) {\n                vars[k] = window.RK_VARS[k];\n            });\n        }\n        return vars;\n    }\n    \n    // Evaluate a single rule\n    function evalRule(rule, vars) {\n        if (!rule || !rule.key) return false;\n        var left = vars[rule.key];\n        var right = rule.value;\n        var op = rule.op || '=';\n        if (left === undefined || left === null) left = '';\n        if (right === undefined || right === null) right = '';\n        var leftStr = String(left);\n        var rightStr = String(right);\n        var result = false;\n        switch (op) {\n            case '=': case '==': result = leftStr === rightStr; break;\n            case '!=': case '<>': result = leftStr !== rightStr; break;\n            case '>': result = parseFloat(left) > parseFloat(right); break;\n            case '<': result = parseFloat(left) < parseFloat(right); break;\n            case '>=': result = parseFloat(left) >= parseFloat(right); break;\n            case '<=': result = parseFloat(left) <= parseFloat(right); break;\n            default: result = false;\n        }\n        return result;\n    }\n    \n    // Evaluate all rules (AND logic)\n    function evalRules(rules, vars) {\n        if (!rules || !rules.length) return true;\n        for (var i = 0; i < rules.length; i++) {\n            if (!evalRule(rules[i], vars)) return false;\n        }\n        return true;\n    }\n    \n    // Execute an action\n    function execAction(action) {\n        if (!action || !action.type) return;\n        var msg = null;\n        var actionType = action.type.toLowerCase();\n        \n        switch (actionType) {\n            case 'navigate':\n                msg = { type: 'rampkit:navigate', targetScreenId: action.targetScreenId || '__continue__', animation: action.animation || 'fade' };\n                break;\n            case 'continue':\n                msg = { type: 'rampkit:navigate', targetScreenId: '__continue__', animation: action.animation || 'fade' };\n                break;\n            case 'goback':\n                msg = { type: 'rampkit:goBack', animation: action.animation || 'fade' };\n                break;\n            case 'close':\n                msg = { type: 'rampkit:close' };\n                break;\n            case 'haptic':\n                msg = { type: 'rampkit:haptic', hapticType: action.hapticType || 'impact', impactStyle: action.impactStyle || 'Medium', notificationType: action.notificationType };\n                break;\n            case 'showpaywall':\n                msg = { type: 'rampkit:show-paywall', payload: action.payload || { paywallId: action.paywallId } };\n                break;\n            case 'requestreview':\n                msg = { type: 'rampkit:request-review' };\n                break;\n            case 'requestnotificationpermission':\n                msg = { type: 'rampkit:request-notification-permission' };\n                break;\n            case 'onboardingfinished':\n                msg = { type: 'rampkit:onboarding-finished', payload: action.payload };\n                break;\n            case 'setvariable':\n            case 'setstate':\n            case 'updatevariable':\n            case 'set':\n            case 'assign':\n                var varKey = action.key || action.variableName || action.name || action.variable;\n                var varValue = action.variableValue !== undefined ? action.variableValue :\n                               action.value !== undefined ? action.value :\n                               action.newValue !== undefined ? action.newValue : undefined;\n                if (varKey && varValue !== undefined) {\n                    if (window.__rampkitVariables) window.__rampkitVariables[varKey] = varValue;\n                    if (window.__rampkitVars) window.__rampkitVars[varKey] = varValue;\n                    var updateVars = {};\n                    updateVars[varKey] = varValue;\n                    msg = { type: 'rampkit:variables', vars: updateVars };\n                }\n                break;\n        }\n        if (msg) {\n            try {\n                if (window.ReactNativeWebView && window.ReactNativeWebView.postMessage) {\n                    window.ReactNativeWebView.postMessage(JSON.stringify(msg));\n                }\n            } catch(e) {}\n        }\n    }\n    \n    // Evaluate dynamic tap config\n    function evalDynamicTap(config) {\n        if (!config || !config.values) return false;\n        var vars = getVars();\n        var conditions = config.values;\n        for (var i = 0; i < conditions.length; i++) {\n            var cond = conditions[i];\n            var condType = cond.conditionType || 'if';\n            var rules = cond.rules || [];\n            var actions = cond.actions || [];\n            if (condType === 'else' || evalRules(rules, vars)) {\n                for (var j = 0; j < actions.length; j++) {\n                    execAction(actions[j]);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    // Click interceptor - capture phase, runs BEFORE onclick handlers\n    function interceptClick(event) {\n        var result = findDynamicTap(event.target);\n        if (!result) return;\n\n        try {\n            var configStr = decodeHtml(result.config);\n            var config = JSON.parse(configStr);\n            var handled = evalDynamicTap(config);\n            if (handled) {\n                event.stopImmediatePropagation();\n                event.preventDefault();\n                return false;\n            }\n        } catch (e) {\n            // Dynamic tap error - silent\n        }\n    }\n\n    // Install interceptor on window in capture phase\n    window.addEventListener('click', interceptClick, true);\n})();\n";
export declare const injectedButtonAnimations = "\n(function(){\n  try {\n    if (window.__rkButtonAnimApplied) return true;\n    window.__rkButtonAnimApplied = true;\n\n    var pressed = null;\n    var pressedOriginalTransform = '';\n    var pressedOriginalOpacity = '';\n    var pressedOriginalTransition = '';\n    var releaseTimer = null;\n\n    // Find interactive element - looks for clickable-looking elements\n    function findInteractive(el) {\n      var current = el;\n      for (var i = 0; i < 20 && current && current !== document.body && current !== document.documentElement; i++) {\n        if (!current || !current.tagName) { current = current.parentElement; continue; }\n        var tag = current.tagName.toLowerCase();\n\n        // Skip tiny elements (likely icons inside buttons)\n        var rect = current.getBoundingClientRect();\n        if (rect.width < 20 || rect.height < 20) { current = current.parentElement; continue; }\n\n        // Match standard interactive elements\n        if (tag === 'button' || tag === 'a' || tag === 'input' || tag === 'select') return current;\n\n        // Match elements with tap/click-related data attributes\n        // Exclude lifecycle attributes like data-on-open-actions, data-on-close-actions\n        var attrs = current.attributes;\n        if (attrs) {\n          for (var j = 0; j < attrs.length; j++) {\n            var attrName = attrs[j].name.toLowerCase();\n            // Skip lifecycle attributes (on-open, on-close, on-load, on-appear, etc.)\n            // These are for screen lifecycle events, not user tap interactions\n            var isLifecycleAttr = (attrName.indexOf('on-open') !== -1 || attrName.indexOf('on-close') !== -1 ||\n                attrName.indexOf('on-load') !== -1 || attrName.indexOf('on-appear') !== -1 ||\n                attrName.indexOf('onopen') !== -1 || attrName.indexOf('onclose') !== -1 ||\n                attrName.indexOf('onload') !== -1 || attrName.indexOf('onappear') !== -1);\n            if (isLifecycleAttr) {\n              continue;\n            }\n            // Match tap/click interaction attributes\n            if (attrName.indexOf('click') !== -1 || attrName.indexOf('tap') !== -1 ||\n                attrName.indexOf('action') !== -1 || attrName.indexOf('navigate') !== -1 ||\n                attrName.indexOf('press') !== -1) {\n              return current;\n            }\n          }\n        }\n\n        // Match elements with onclick\n        if (current.onclick || current.hasAttribute('onclick')) return current;\n\n        // Match elements with role=\"button\"\n        if (current.getAttribute('role') === 'button') return current;\n\n        // Match any element with an ID containing button/btn/cta\n        var id = current.id || '';\n        if (id && (id.toLowerCase().indexOf('button') !== -1 || id.toLowerCase().indexOf('btn') !== -1 || id.toLowerCase().indexOf('cta') !== -1)) return current;\n\n        // Match elements with button-like classes\n        var className = current.className;\n        if (className && typeof className === 'string') {\n          var cls = className.toLowerCase();\n          if (cls.indexOf('btn') !== -1 || cls.indexOf('button') !== -1 || cls.indexOf('cta') !== -1 ||\n              cls.indexOf('clickable') !== -1 || cls.indexOf('tappable') !== -1 || cls.indexOf('pressable') !== -1) {\n            return current;\n          }\n        }\n\n        // Match elements with cursor pointer\n        try {\n          var computed = window.getComputedStyle(current);\n          if (computed && computed.cursor === 'pointer') return current;\n        } catch(e) {}\n\n        current = current.parentElement;\n      }\n      return null;\n    }\n\n    function applyPressedStyle(el) {\n      if (!el || !el.style) return;\n      // Save original styles\n      pressedOriginalTransform = el.style.transform || '';\n      pressedOriginalOpacity = el.style.opacity || '';\n      pressedOriginalTransition = el.style.transition || '';\n      // Apply pressed style with inline styles for maximum specificity\n      el.style.transition = 'transform 80ms cubic-bezier(0.25, 0.1, 0.25, 1), opacity 80ms cubic-bezier(0.25, 0.1, 0.25, 1)';\n      el.style.transform = 'scale(0.97)';\n      el.style.opacity = '0.8';\n    }\n\n    function applyReleasedStyle(el) {\n      if (!el || !el.style) return;\n      // Apply spring-back animation\n      el.style.transition = 'transform 280ms cubic-bezier(0.34, 1.56, 0.64, 1), opacity 280ms cubic-bezier(0.34, 1.56, 0.64, 1)';\n      el.style.transform = pressedOriginalTransform || 'scale(1)';\n      el.style.opacity = pressedOriginalOpacity || '1';\n    }\n\n    function resetStyle(el) {\n      if (!el || !el.style) return;\n      el.style.transform = pressedOriginalTransform;\n      el.style.opacity = pressedOriginalOpacity;\n      el.style.transition = pressedOriginalTransition;\n    }\n\n    function onTouchStart(e) {\n      try {\n        var target = findInteractive(e.target);\n        if (!target) return;\n        if (releaseTimer) { clearTimeout(releaseTimer); releaseTimer = null; }\n        if (pressed && pressed !== target) { resetStyle(pressed); }\n        applyPressedStyle(target);\n        pressed = target;\n      } catch(err) {}\n    }\n    \n    function onTouchEnd(e) {\n      try {\n        if (!pressed) return;\n        var t = pressed;\n        applyReleasedStyle(t);\n        releaseTimer = setTimeout(function() {\n          resetStyle(t);\n          releaseTimer = null;\n        }, 300);\n        pressed = null;\n      } catch(err) {}\n    }\n    \n    function onTouchCancel(e) {\n      try {\n        if (!pressed) return;\n        resetStyle(pressed);\n        pressed = null;\n        if (releaseTimer) { clearTimeout(releaseTimer); releaseTimer = null; }\n      } catch(err) {}\n    }\n    \n    // Use capture phase for immediate response before any other handlers\n    document.addEventListener('touchstart', onTouchStart, { passive: true, capture: true });\n    document.addEventListener('touchend', onTouchEnd, { passive: true, capture: true });\n    document.addEventListener('touchcancel', onTouchCancel, { passive: true, capture: true });\n    // Mouse events for testing\n    document.addEventListener('mousedown', onTouchStart, { passive: true, capture: true });\n    document.addEventListener('mouseup', onTouchEnd, { passive: true, capture: true });\n    \n  } catch (err) {}\n  true;\n})();\n";
export type ScreenPayload = {
    id: string;
    html: string;
    css?: string;
    js?: string;
};
export declare function showRampkitOverlay(opts: {
    onboardingId: string;
    screens: ScreenPayload[];
    variables?: Record<string, any>;
    requiredScripts?: string[];
    rampkitContext?: RampKitContext;
    navigation?: NavigationData;
    onClose?: () => void;
    onOnboardingFinished?: (payload?: any) => void;
    onShowPaywall?: (payload?: any) => void;
    onScreenChange?: (screenIndex: number, screenId: string) => void;
    onOnboardingAbandoned?: (reason: string, lastScreenIndex: number, lastScreenId: string) => void;
    onNotificationPermissionRequested?: () => void;
    onNotificationPermissionResult?: (granted: boolean) => void;
    onCloseAction?: (screenIndex: number, screenId: string) => void;
}): void;
export declare function hideRampkitOverlay(): void;
export declare function closeRampkitOverlay(): void;
export declare function preloadRampkitOverlay(opts: {
    onboardingId: string;
    screens: ScreenPayload[];
    variables?: Record<string, any>;
    requiredScripts?: string[];
    rampkitContext?: RampKitContext;
}): void;
declare function Overlay(props: {
    onboardingId: string;
    screens: ScreenPayload[];
    variables?: Record<string, any>;
    requiredScripts?: string[];
    rampkitContext?: RampKitContext;
    navigation?: NavigationData;
    prebuiltDocs?: string[];
    onRequestClose: () => void;
    onOnboardingFinished?: (payload?: any) => void;
    onShowPaywall?: (payload?: any) => void;
    onRegisterClose?: (handler: (() => void) | null) => void;
    onScreenChange?: (screenIndex: number, screenId: string) => void;
    onOnboardingAbandoned?: (reason: string, lastScreenIndex: number, lastScreenId: string) => void;
    onNotificationPermissionRequested?: () => void;
    onNotificationPermissionResult?: (granted: boolean) => void;
    onCloseAction?: (screenIndex: number, screenId: string) => void;
}): any;
export default Overlay;
